/* tslint:disable */
/* eslint-disable */
/**
 * API reference
 * The Blowfish API reference specification
 *
 * The version of the OpenAPI document: 2022-06-01
 * Contact: contact@blowfish.xyz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { ScanMessageEvm200ResponseSimulationResultsError } from './ScanMessageEvm200ResponseSimulationResultsError';
import {
    ScanMessageEvm200ResponseSimulationResultsErrorFromJSON,
    ScanMessageEvm200ResponseSimulationResultsErrorFromJSONTyped,
    ScanMessageEvm200ResponseSimulationResultsErrorToJSON,
} from './ScanMessageEvm200ResponseSimulationResultsError';
import type { ScanMessageEvm200ResponseSimulationResultsExpectedStateChangesInner } from './ScanMessageEvm200ResponseSimulationResultsExpectedStateChangesInner';
import {
    ScanMessageEvm200ResponseSimulationResultsExpectedStateChangesInnerFromJSON,
    ScanMessageEvm200ResponseSimulationResultsExpectedStateChangesInnerFromJSONTyped,
    ScanMessageEvm200ResponseSimulationResultsExpectedStateChangesInnerToJSON,
} from './ScanMessageEvm200ResponseSimulationResultsExpectedStateChangesInner';

/**
 * Can be `null`. Message simulation requires in-depth understanding of the contract verifying the message and is not a generalizable solution that works for any message. If we do not support simulating a particular message the simulationResults property will be returned as null and the recommended action is to fallback to showing the raw message data to the user before they sign
 * Currently supported messages: OpenSea Seaport orders & ERC20 Permit approvals
 * @export
 * @interface ScanMessageEvm200ResponseSimulationResults
 */
export interface ScanMessageEvm200ResponseSimulationResults {
    /**
     * 
     * @type {Array<ScanMessageEvm200ResponseSimulationResultsExpectedStateChangesInner>}
     * @memberof ScanMessageEvm200ResponseSimulationResults
     */
    expectedStateChanges: Array<ScanMessageEvm200ResponseSimulationResultsExpectedStateChangesInner>;
    /**
     * 
     * @type {ScanMessageEvm200ResponseSimulationResultsError}
     * @memberof ScanMessageEvm200ResponseSimulationResults
     */
    error: ScanMessageEvm200ResponseSimulationResultsError | null;
}

/**
 * Check if a given object implements the ScanMessageEvm200ResponseSimulationResults interface.
 */
export function instanceOfScanMessageEvm200ResponseSimulationResults(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "expectedStateChanges" in value;
    isInstance = isInstance && "error" in value;

    return isInstance;
}

export function ScanMessageEvm200ResponseSimulationResultsFromJSON(json: any): ScanMessageEvm200ResponseSimulationResults {
    return ScanMessageEvm200ResponseSimulationResultsFromJSONTyped(json, false);
}

export function ScanMessageEvm200ResponseSimulationResultsFromJSONTyped(json: any, ignoreDiscriminator: boolean): ScanMessageEvm200ResponseSimulationResults {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'expectedStateChanges': ((json['expectedStateChanges'] as Array<any>).map(ScanMessageEvm200ResponseSimulationResultsExpectedStateChangesInnerFromJSON)),
        'error': ScanMessageEvm200ResponseSimulationResultsErrorFromJSON(json['error']),
    };
}

export function ScanMessageEvm200ResponseSimulationResultsToJSON(value?: ScanMessageEvm200ResponseSimulationResults | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'expectedStateChanges': ((value.expectedStateChanges as Array<any>).map(ScanMessageEvm200ResponseSimulationResultsExpectedStateChangesInnerToJSON)),
        'error': ScanMessageEvm200ResponseSimulationResultsErrorToJSON(value.error),
    };
}

