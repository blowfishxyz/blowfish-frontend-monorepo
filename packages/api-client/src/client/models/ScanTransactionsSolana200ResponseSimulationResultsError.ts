/* tslint:disable */
/* eslint-disable */
/**
 * API reference
 * The Blowfish API reference specification
 *
 * The version of the OpenAPI document: 2022-06-01
 * Contact: contact@blowfish.xyz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * An error object which includes the parsed simulation error encountered (if any). Can be `null`.
 * @export
 * @interface ScanTransactionsSolana200ResponseSimulationResultsError
 */
export interface ScanTransactionsSolana200ResponseSimulationResultsError {
    /**
     * A unique representation of the error kind. Currently maps to the screaming case of the SystemError enum values, TokenError and TransactionError enum values. It returns `UNKNOWN_ERROR` if the Solana program reverts with an error we are unable to decode.
     * @type {string}
     * @memberof ScanTransactionsSolana200ResponseSimulationResultsError
     */
    kind: ScanTransactionsSolana200ResponseSimulationResultsErrorKindEnum;
    /**
     * Human readable version of the error
     * @type {string}
     * @memberof ScanTransactionsSolana200ResponseSimulationResultsError
     */
    humanReadableError: string;
}


/**
 * @export
 */
export const ScanTransactionsSolana200ResponseSimulationResultsErrorKindEnum = {
    SimulationFailed: 'SIMULATION_FAILED',
    SimulationTimedOut: 'SIMULATION_TIMED_OUT',
    TooManyTransactions: 'TOO_MANY_TRANSACTIONS',
    BadRequest: 'BAD_REQUEST',
    AnAccountWithTheSameAddressAlreadyExists: 'AN_ACCOUNT_WITH_THE_SAME_ADDRESS_ALREADY_EXISTS',
    AccountDoesNotHaveEnoughSolToPerformTheOperation: 'ACCOUNT_DOES_NOT_HAVE_ENOUGH_SOL_TO_PERFORM_THE_OPERATION',
    CannotAssignAccountToThisProgramId: 'CANNOT_ASSIGN_ACCOUNT_TO_THIS_PROGRAM_ID',
    CannotAllocateAccountDataOfThisLength: 'CANNOT_ALLOCATE_ACCOUNT_DATA_OF_THIS_LENGTH',
    LengthOfRequestedSeedIsTooLong: 'LENGTH_OF_REQUESTED_SEED_IS_TOO_LONG',
    ProvidedAddressDoesNotMatchAddressedDerivedFromSeed: 'PROVIDED_ADDRESS_DOES_NOT_MATCH_ADDRESSED_DERIVED_FROM_SEED',
    AdvancingStoredNonceRequiresAPopulatedRecentblockhashesSysvar: 'ADVANCING_STORED_NONCE_REQUIRES_A_POPULATED_RECENTBLOCKHASHES_SYSVAR',
    StoredNonceIsStillInRecentBlockhashes: 'STORED_NONCE_IS_STILL_IN_RECENT_BLOCKHASHES',
    SpecifiedNonceDoesNotMatchStoredNonce: 'SPECIFIED_NONCE_DOES_NOT_MATCH_STORED_NONCE',
    LamportBalanceBelowRentExemptThreshold: 'LAMPORT_BALANCE_BELOW_RENT-EXEMPT_THRESHOLD',
    InsufficientFunds: 'INSUFFICIENT_FUNDS',
    InvalidMint: 'INVALID_MINT',
    AccountNotAssociatedWithThisMint: 'ACCOUNT_NOT_ASSOCIATED_WITH_THIS_MINT',
    OwnerDoesNotMatch: 'OWNER_DOES_NOT_MATCH',
    FixedSupply: 'FIXED_SUPPLY',
    AlreadyInUse: 'ALREADY_IN_USE',
    InvalidNumberOfProvidedSigners: 'INVALID_NUMBER_OF_PROVIDED_SIGNERS',
    InvalidNumberOfRequiredSigners: 'INVALID_NUMBER_OF_REQUIRED_SIGNERS',
    StateIsUninitialized: 'STATE_IS_UNINITIALIZED',
    InstructionDoesNotSupportNativeTokens: 'INSTRUCTION_DOES_NOT_SUPPORT_NATIVE_TOKENS',
    NonNativeAccountCanOnlyBeClosedIfItsBalanceIsZero: 'NON-NATIVE_ACCOUNT_CAN_ONLY_BE_CLOSED_IF_ITS_BALANCE_IS_ZERO',
    InvalidInstruction: 'INVALID_INSTRUCTION',
    StateIsInvalidForRequestedOperation: 'STATE_IS_INVALID_FOR_REQUESTED_OPERATION',
    OperationOverflowed: 'OPERATION_OVERFLOWED',
    AccountDoesNotSupportSpecifiedAuthorityType: 'ACCOUNT_DOES_NOT_SUPPORT_SPECIFIED_AUTHORITY_TYPE',
    ThisTokenMintCannotFreezeAccounts: 'THIS_TOKEN_MINT_CANNOT_FREEZE_ACCOUNTS',
    AccountIsFrozen: 'ACCOUNT_IS_FROZEN',
    TheProvidedDecimalsValueDifferentFromTheMintDecimals: 'THE_PROVIDED_DECIMALS_VALUE_DIFFERENT_FROM_THE_MINT_DECIMALS',
    InstructionDoesNotSupportNonNativeTokens: 'INSTRUCTION_DOES_NOT_SUPPORT_NON-NATIVE_TOKENS',
    AccountInUse: 'ACCOUNT_IN_USE',
    AccountLoadedTwice: 'ACCOUNT_LOADED_TWICE',
    AttemptToDebitAnAccountButFoundNoRecordOfAPriorCredit: 'ATTEMPT_TO_DEBIT_AN_ACCOUNT_BUT_FOUND_NO_RECORD_OF_A_PRIOR_CREDIT.',
    AttemptToLoadAProgramThatDoesNotExist: 'ATTEMPT_TO_LOAD_A_PROGRAM_THAT_DOES_NOT_EXIST',
    InsufficientFundsForFee: 'INSUFFICIENT_FUNDS_FOR_FEE',
    ThisAccountMayNotBeUsedToPayTransactionFees: 'THIS_ACCOUNT_MAY_NOT_BE_USED_TO_PAY_TRANSACTION_FEES',
    ThisTransactionHasAlreadyBeenProcessed: 'THIS_TRANSACTION_HAS_ALREADY_BEEN_PROCESSED',
    BlockhashNotFound: 'BLOCKHASH_NOT_FOUND',
    ErrorProcessingInstruction01: 'ERROR_PROCESSING_INSTRUCTION_{0}:_{1}',
    LoaderCallChainIsTooDeep: 'LOADER_CALL_CHAIN_IS_TOO_DEEP',
    TransactionRequiresAFeeButHasNoSignaturePresent: 'TRANSACTION_REQUIRES_A_FEE_BUT_HAS_NO_SIGNATURE_PRESENT',
    TransactionContainsAnInvalidAccountReference: 'TRANSACTION_CONTAINS_AN_INVALID_ACCOUNT_REFERENCE',
    TransactionDidNotPassSignatureVerification: 'TRANSACTION_DID_NOT_PASS_SIGNATURE_VERIFICATION',
    ThisProgramMayNotBeUsedForExecutingInstructions: 'THIS_PROGRAM_MAY_NOT_BE_USED_FOR_EXECUTING_INSTRUCTIONS',
    TransactionFailedToSanitizeAccountsOffsetsCorrectly: 'TRANSACTION_FAILED_TO_SANITIZE_ACCOUNTS_OFFSETS_CORRECTLY',
    TransactionsAreCurrentlyDisabledDueToClusterMaintenance: 'TRANSACTIONS_ARE_CURRENTLY_DISABLED_DUE_TO_CLUSTER_MAINTENANCE',
    TransactionProcessingLeftAnAccountWithAnOutstandingBorrowedReference: 'TRANSACTION_PROCESSING_LEFT_AN_ACCOUNT_WITH_AN_OUTSTANDING_BORROWED_REFERENCE',
    TransactionWouldExceedMaxBlockCostLimit: 'TRANSACTION_WOULD_EXCEED_MAX_BLOCK_COST_LIMIT',
    TransactionVersionIsUnsupported: 'TRANSACTION_VERSION_IS_UNSUPPORTED',
    TransactionLoadsAWritableAccountThatCannotBeWritten: 'TRANSACTION_LOADS_A_WRITABLE_ACCOUNT_THAT_CANNOT_BE_WRITTEN',
    TransactionWouldExceedMaxAccountLimitWithinTheBlock: 'TRANSACTION_WOULD_EXCEED_MAX_ACCOUNT_LIMIT_WITHIN_THE_BLOCK',
    TransactionWouldExceedAccountDataLimitWithinTheBlock: 'TRANSACTION_WOULD_EXCEED_ACCOUNT_DATA_LIMIT_WITHIN_THE_BLOCK',
    TransactionLockedTooManyAccounts: 'TRANSACTION_LOCKED_TOO_MANY_ACCOUNTS',
    TransactionLoadsAnAddressTableAccountThatDoesntExist: 'TRANSACTION_LOADS_AN_ADDRESS_TABLE_ACCOUNT_THAT_DOESN\'T_EXIST',
    TransactionLoadsAnAddressTableAccountWithAnInvalidOwner: 'TRANSACTION_LOADS_AN_ADDRESS_TABLE_ACCOUNT_WITH_AN_INVALID_OWNER',
    TransactionLoadsAnAddressTableAccountWithInvalidData: 'TRANSACTION_LOADS_AN_ADDRESS_TABLE_ACCOUNT_WITH_INVALID_DATA',
    TransactionAddressTableLookupUsesAnInvalidIndex: 'TRANSACTION_ADDRESS_TABLE_LOOKUP_USES_AN_INVALID_INDEX',
    TransactionLeavesAnAccountWithALowerBalanceThanRentExemptMinimum: 'TRANSACTION_LEAVES_AN_ACCOUNT_WITH_A_LOWER_BALANCE_THAN_RENT-EXEMPT_MINIMUM',
    TransactionWouldExceedMaxVoteCostLimit: 'TRANSACTION_WOULD_EXCEED_MAX_VOTE_COST_LIMIT',
    TransactionWouldExceedTotalAccountDataLimit: 'TRANSACTION_WOULD_EXCEED_TOTAL_ACCOUNT_DATA_LIMIT',
    TransactionContainsADuplicateInstruction0ThatIsNotAllowed: 'TRANSACTION_CONTAINS_A_DUPLICATE_INSTRUCTION_({0})_THAT_IS_NOT_ALLOWED',
    UnknownError: 'UNKNOWN_ERROR'
} as const;
export type ScanTransactionsSolana200ResponseSimulationResultsErrorKindEnum = typeof ScanTransactionsSolana200ResponseSimulationResultsErrorKindEnum[keyof typeof ScanTransactionsSolana200ResponseSimulationResultsErrorKindEnum];


/**
 * Check if a given object implements the ScanTransactionsSolana200ResponseSimulationResultsError interface.
 */
export function instanceOfScanTransactionsSolana200ResponseSimulationResultsError(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "kind" in value;
    isInstance = isInstance && "humanReadableError" in value;

    return isInstance;
}

export function ScanTransactionsSolana200ResponseSimulationResultsErrorFromJSON(json: any): ScanTransactionsSolana200ResponseSimulationResultsError {
    return ScanTransactionsSolana200ResponseSimulationResultsErrorFromJSONTyped(json, false);
}

export function ScanTransactionsSolana200ResponseSimulationResultsErrorFromJSONTyped(json: any, ignoreDiscriminator: boolean): ScanTransactionsSolana200ResponseSimulationResultsError {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'kind': json['kind'],
        'humanReadableError': json['humanReadableError'],
    };
}

export function ScanTransactionsSolana200ResponseSimulationResultsErrorToJSON(value?: ScanTransactionsSolana200ResponseSimulationResultsError | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'kind': value.kind,
        'humanReadableError': value.humanReadableError,
    };
}

